// تجنب التلوث العام
(function() {
    "use strict";

    // ============== التعريفات العامة ==============
    const EShape = {
        RECTANGLE: "0",
        ELLIPSIS: "1",
        CIRCLE: "2"
    };

    const EMode = {
        MONOCHROME: "0",
        COLORS: "1"
    };

    const EColor = {
        MONOCHROME: 0,
        RED: 1,
        GREEN: 2,
        BLUE: 3
    };

    const ECompositingOperation = {
        DARKEN: 0,
        LIGHTEN: 1
    };

    // ============== إعدادات التطبيق ==============
    class Parameters {
        static get shape() {
            return document.querySelector('input[name="shape"]:checked').value;
        }
        static get pegsCount() {
            return parseInt(document.getElementById('pegs-range').value);
        }
        static get mode() {
            return document.querySelector('input[name="mode"]:checked').value;
        }
        static get nbLines() {
            return parseInt(document.getElementById('lines-range').value);
        }
        static get linesOpacity() {
            let val = parseInt(document.getElementById('opacity-range').value);
            return Math.pow(2, val - 7);
        }
        static get linesThickness() {
            return parseInt(document.getElementById('thickness-range').value);
        }
        static get displayPegs() {
            return document.getElementById('display-pegs-checkbox').checked;
        }
        static get invertColors() {
            return document.getElementById('invert-colors-checkbox').checked;
        }
        static get blur() {
            return parseInt(document.getElementById('blur-range').value);
        }
        static get canvasWidth() {
            return parseInt(document.getElementById('canvas-width-range').value);
        }
        static get canvasHeight() {
            return parseInt(document.getElementById('canvas-height-range').value);
        }
        static get quality() {
            return parseFloat(document.querySelector('input[name="quality"]:checked').value);
        }

        // مراقبون (observers) للتغييرات
        static addRedrawObserver(callback) {
            Parameters.redrawObservers.push(callback);
        }
        static addResetObserver(callback) {
            Parameters.resetObservers.push(callback);
        }
        static addBlurChangeObserver(callback) {
            Parameters.blurChangeObservers.push(callback);
        }
        static addFileUploadObserver(callback) {
            Parameters.fileUploadObservers.push(callback);
        }
        static addDownloadObserver(callback) {
            Parameters.downloadObservers.push(callback);
        }
        static addDownloadInstructionsObserver(callback) {
            Parameters.downloadInstructionsObservers.push(callback);
        }

        static redrawObservers = [];
        static resetObservers = [];
        static blurChangeObservers = [];
        static fileUploadObservers = [];
        static downloadObservers = [];
        static downloadInstructionsObservers = [];

        static notifyRedraw() {
            Parameters.redrawObservers.forEach(obs => obs());
        }
        static notifyReset() {
            Parameters.resetObservers.forEach(obs => obs());
        }
        static notifyBlurChange(value) {
            Parameters.blurChangeObservers.forEach(obs => obs(value));
        }
        static notifyFileUpload(files) {
            Parameters.fileUploadObservers.forEach(obs => obs(files));
        }
        static notifyDownload() {
            Parameters.downloadObservers.forEach(obs => obs());
        }
        static notifyDownloadInstructions() {
            Parameters.downloadInstructionsObservers.forEach(obs => obs());
        }
    }

    // ============== أدوات مساعدة ==============
    const Helpers = {
        downloadTextFile: function(text, filename) {
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            setTimeout(() => URL.revokeObjectURL(url), 5000);
        },

        getQueryStringValue: function(key) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(key);
        }
    };

    // ============== نظام الرسم ==============
    class PlotterBase {
        drawBrokenLine(points, color, opacity, operation, thickness) {
            const lines = [];
            for (let i = 0; i < points.length - 1; i++) {
                lines.push({ from: points[i], to: points[i + 1] });
            }
            this.drawLines(lines, color, opacity, operation, thickness);
        }

        drawLines(lines, color, opacity, operation, thickness) {
            // يجب تنفيذها في الفئات المشتقة
        }

        drawPoints(points, color, size) {
            // يجب تنفيذها في الفئات المشتقة
        }
    }

    class PlotterCanvas2D extends PlotterBase {
        constructor(canvasId) {
            super();
            this.canvas = document.getElementById(canvasId);
            this.context = this.canvas.getContext('2d', { alpha: false });
            this.cssPixel = window.devicePixelRatio || 1;
            this.resize();
        }

        resize() {
            const width = Math.floor(this.cssPixel * this.canvas.clientWidth);
            const height = Math.floor(this.cssPixel * this.canvas.clientHeight);
            if (this.canvas.width !== width || this.canvas.height !== height) {
                this.canvas.width = width;
                this.canvas.height = height;
            }
        }

        initialize(settings) {
            this.context.fillStyle = settings.backgroundColor;
            this.context.lineJoin = 'round';
            this.context.globalCompositeOperation = 'source-over';
            this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }

        finalize() {
            // لا شيء
        }

        set blur(value) {
            if (value === 0) {
                this.canvas.style.filter = '';
            } else {
                this.canvas.style.filter = `blur(${value}px)`;
            }
        }

        drawLines(lines, color, opacity, operation, thickness) {
            if (lines.length < 1) return;

            // تطبيق التركيب (compositing)
            if (operation === ECompositingOperation.LIGHTEN) {
                this.context.globalCompositeOperation = 'lighter';
            } else {
                this.context.globalCompositeOperation = 'difference';
            }

            // حساب اللون
            let strokeStyle;
            if (color === EColor.MONOCHROME) {
                const gray = Math.ceil(255 * opacity);
                strokeStyle = `rgb(${gray}, ${gray}, ${gray})`;
            } else {
                const r = (color === EColor.RED) ? Math.ceil(255 * opacity) : 0;
                const g = (color === EColor.GREEN) ? Math.ceil(255 * opacity) : 0;
                const b = (color === EColor.BLUE) ? Math.ceil(255 * opacity) : 0;
                strokeStyle = `rgb(${r}, ${g}, ${b})`;
            }

            this.context.strokeStyle = strokeStyle;
            this.context.lineWidth = thickness * this.cssPixel;

            for (const line of lines) {
                this.context.beginPath();
                this.context.moveTo(line.from.x * this.cssPixel, line.from.y * this.cssPixel);
                this.context.lineTo(line.to.x * this.cssPixel, line.to.y * this.cssPixel);
                this.context.stroke();
                this.context.closePath();
            }

            // إعادة الضبط
            this.context.globalCompositeOperation = 'source-over';
        }

        drawPoints(points, color, size) {
            if (points.length === 0) return;
            this.context.fillStyle = color;
            this.context.strokeStyle = 'none';
            for (const point of points) {
                this.context.beginPath();
                this.context.arc(point.x * this.cssPixel, point.y * this.cssPixel, 0.5 * size * this.cssPixel, 0, 2 * Math.PI);
                this.context.fill();
                this.context.closePath();
            }
        }

        get size() {
            return {
                width: Math.floor(this.canvas.width / this.cssPixel),
                height: Math.floor(this.canvas.height / this.cssPixel)
            };
        }
    }

    // ============== خوارزمية توليد الخيط ==============
    class ThreadBase {
        constructor() {
            this.sampleCanvas = null;
        }

        static lowerNbSegmentsForThread(thread, nbSegments) {
            thread.length = nbSegments > 0 ? Math.min(thread.length, nbSegments + 1) : 0;
        }

        static computeNbSegments(thread) {
            return thread.length > 1 ? thread.length - 1 : 0;
        }

        static iterateOnThread(thread, color, startSegment, callback) {
            if (startSegment < ThreadBase.computeNbSegments(thread)) {
                callback(thread.slice(startSegment), color);
            }
        }
    }

    class ThreadMonochrome extends ThreadBase {
        constructor() {
            super();
            this.threadPegs = [];
        }

        get totalNbSegments() {
            return ThreadBase.computeNbSegments(this.threadPegs);
        }

        lowerNbSegments(nbSegments) {
            ThreadBase.lowerNbSegmentsForThread(this.threadPegs, nbSegments);
        }

        iterateOnThreads(startSegment, callback) {
            ThreadBase.iterateOnThread(this.threadPegs, EColor.MONOCHROME, startSegment, callback);
        }

        getThreadToGrow() {
            return { thread: this.threadPegs, color: EColor.MONOCHROME };
        }

        adjustCanvasData(imageData, invertColors) {
            const n = invertColors ? (value) => (255 - value) / 2 : (value) => value / 2;
            for (let i = 0; i < imageData.length; i += 4) {
                const gray = n((imageData[i] + imageData[i + 1] + imageData[i + 2]) / 3);
                imageData[i] = gray;
                imageData[i + 1] = gray;
                imageData[i + 2] = gray;
            }
        }

        enableSamplingFor() {
            if (this.sampleCanvas === null) {
                this.sampleCanvas = (data, index) => data[index];
            }
        }
    }

    class ThreadRedBlueGreen extends ThreadBase {
        constructor() {
            super();
            this.threadPegsRed = [];
            this.threadPegsGreen = [];
            this.threadPegsBlue = [];
            this.frequencyRed = 0;
            this.frequencyGreen = 0;
            this.frequencyBlue = 0;
        }

        get totalNbSegments() {
            return ThreadBase.computeNbSegments(this.threadPegsRed) +
                   ThreadBase.computeNbSegments(this.threadPegsGreen) +
                   ThreadBase.computeNbSegments(this.threadPegsBlue);
        }

        lowerNbSegments(nbSegments) {
            const ideal = this.computeIdealSegmentsRepartition(nbSegments);
            ThreadBase.lowerNbSegmentsForThread(this.threadPegsRed, ideal.red);
            ThreadBase.lowerNbSegmentsForThread(this.threadPegsGreen, ideal.green);
            ThreadBase.lowerNbSegmentsForThread(this.threadPegsBlue, ideal.blue);
        }

        iterateOnThreads(startSegment, callback) {
            const ideal = this.computeIdealSegmentsRepartition(startSegment);
            ThreadBase.iterateOnThread(this.threadPegsRed, EColor.RED, ideal.red, callback);
            ThreadBase.iterateOnThread(this.threadPegsGreen, EColor.GREEN, ideal.green, callback);
            ThreadBase.iterateOnThread(this.threadPegsBlue, EColor.BLUE, ideal.blue, callback);
        }

        getThreadToGrow() {
            const ideal = this.computeIdealSegmentsRepartition(this.totalNbSegments + 1);
            if (ideal.red > 0 && this.threadPegsRed.length < ideal.red + 1) {
                return { thread: this.threadPegsRed, color: EColor.RED };
            } else if (ideal.green > 0 && this.threadPegsGreen.length < ideal.green + 1) {
                return { thread: this.threadPegsGreen, color: EColor.GREEN };
            } else {
                return { thread: this.threadPegsBlue, color: EColor.BLUE };
            }
        }

        adjustCanvasData(imageData, invertColors) {
            let totalRed = 0, totalGreen = 0, totalBlue = 0;
            const n = invertColors ? (value) => (255 - value) / 2 : (value) => value / 2;

            for (let i = 0; i < imageData.length; i += 4) {
                totalRed += imageData[i];
                totalGreen += imageData[i + 1];
                totalBlue += imageData[i + 2];
                imageData[i] = n(imageData[i]);
                imageData[i + 1] = n(imageData[i + 1]);
                imageData[i + 2] = n(imageData[i + 2]);
            }

            if (!invertColors) {
                const totalPixels = imageData.length / 4;
                totalRed = 255 * totalPixels - totalRed;
                totalGreen = 255 * totalPixels - totalGreen;
                totalBlue = 255 * totalPixels - totalBlue;
            }

            const total = totalRed + totalGreen + totalBlue;
            this.frequencyRed = totalRed / total;
            this.frequencyGreen = totalGreen / total;
            this.frequencyBlue = totalBlue / total;
        }

        enableSamplingFor(color) {
            let offset;
            if (color === EColor.RED) offset = 0;
            else if (color === EColor.GREEN) offset = 1;
            else offset = 2;

            this.sampleCanvas = (data, index) => data[index + offset];
        }

        computeIdealSegmentsRepartition(totalSegments) {
            const red = Math.floor(totalSegments * this.frequencyRed);
            const green = Math.floor(totalSegments * this.frequencyGreen);
            const blue = Math.floor(totalSegments * this.frequencyBlue);
            const result = { red, green, blue };

            // توزيع الجزء المتبقي
            while (result.red + result.green + result.blue < totalSegments) {
                const errorRed = totalSegments * this.frequencyRed - result.red;
                const errorGreen = totalSegments * this.frequencyGreen - result.green;
                const errorBlue = totalSegments * this.frequencyBlue - result.blue;

                if (errorRed > errorGreen && errorRed > errorBlue) {
                    result.red++;
                } else if (errorGreen > errorRed && errorGreen > errorBlue) {
                    result.green++;
                } else {
                    result.blue++;
                }
            }

            return result;
        }
    }

    // ============== محرك الحساب الرئيسي ==============
    class ThreadComputer {
        constructor(sourceImage) {
            this.sourceImage = sourceImage;
            this.hiddenCanvas = document.createElement('canvas');
            this.hiddenCanvasContext = this.hiddenCanvas.getContext('2d');
            this.hiddenCanvasData = null;
            this.pegs = [];
            this.error = { average: 0, variance: 0, meanSquare: 0 };
            this.lineOpacity = 0.0625;
            this.lineThickness = 1;
            this.hiddenCanvasScale = 1;
            this.lineOpacityInternal = 0;
            this.nbSegments = 0;
            this.thread = null;
            this.totalThreadLength = 0; // إضافة لحساب الطول

            this.reset(this.lineOpacity, this.lineThickness);
        }

        reset(lineOpacity, lineThickness) {
            this.lineOpacity = lineOpacity;
            this.lineThickness = lineThickness;
            this.hiddenCanvasScale = Parameters.quality;
            if (Parameters.mode === EMode.MONOCHROME) {
                this.thread = new ThreadMonochrome();
            } else {
                this.thread = new ThreadRedBlueGreen();
            }
            this.resetHiddenCanvas();
            this.pegs = this.computePegs();
            this.nbSegments = 0;
            this.totalThreadLength = 0;
        }

        resetHiddenCanvas() {
            // حساب حجم canvas المخفي بناءً على جودة الصورة
            const bestSize = ThreadComputer.computeBestSize(this.sourceImage, 100 * this.hiddenCanvasScale);
            this.hiddenCanvas.width = bestSize.width;
            this.hiddenCanvas.height = bestSize.height;

            // رسم الصورة الأصلية
            this.hiddenCanvasContext.globalCompositeOperation = 'source-over';
            this.hiddenCanvasContext.drawImage(this.sourceImage, 0, 0, bestSize.width, bestSize.height);

            // تعديل بيانات الصورة حسب الوضع (أحادي اللون أو ألوان)
            const imageData = this.hiddenCanvasContext.getImageData(0, 0, bestSize.width, bestSize.height);
            this.thread.adjustCanvasData(imageData.data, Parameters.invertColors);
            this.hiddenCanvasContext.putImageData(imageData, 0, 0);

            this.computeError();
            this.initializeHiddenCanvasLineProperties();
        }

        initializeHiddenCanvasLineProperties() {
            const lineWidth = this.lineThickness * this.hiddenCanvasScale;
            if (lineWidth <= 1) {
                this.lineOpacityInternal = 0.5 * this.lineOpacity * lineWidth;
                this.hiddenCanvasContext.lineWidth = 1;
            } else {
                this.lineOpacityInternal = 0.5 * this.lineOpacity;
                this.hiddenCanvasContext.lineWidth = lineWidth;
            }
        }

        computePegs() {
            const width = Parameters.canvasWidth || 1000;
            const height = Parameters.canvasHeight || 1000;
            const pegsCount = Parameters.pegsCount;
            const shape = Parameters.shape;
            const pegs = [];

            if (shape === EShape.RECTANGLE) {
                // حساب دبابيس المستطيل
                const hRatio = height / width;
                const pegsHorizontal = Math.round(0.5 * pegsCount / (1 + hRatio));
                const pegsVertical = Math.round(0.5 * (pegsCount - 2 * pegsHorizontal));

                pegs.push({ x: 0, y: 0 });
                for (let i = 1; i < pegsHorizontal; i++) {
                    pegs.push({ x: width * (i / pegsHorizontal), y: 0 });
                }
                pegs.push({ x: width, y: 0 });
                for (let i = 1; i < pegsVertical; i++) {
                    pegs.push({ x: width, y: height * (i / pegsVertical) });
                }
                pegs.push({ x: width, y: height });
                for (let i = pegsHorizontal - 1; i >= 1; i--) {
                    pegs.push({ x: width * (i / pegsHorizontal), y: height });
                }
                pegs.push({ x: 0, y: height });
                for (let i = pegsVertical - 1; i >= 1; i--) {
                    pegs.push({ x: 0, y: height * (i / pegsVertical) });
                }
            } else if (shape === EShape.ELLIPSIS) {
                // حساب دبابيس القطع الناقص
                const a = width / 2;
                const b = height / 2;
                const perimeter = Math.PI * (3 * (a + b) - Math.sqrt((3 * a + b) * (a + 3 * b)));
                const step = perimeter / pegsCount;
                let angle = 0;

                while (pegs.length < pegsCount) {
                    const x = a * (1 + Math.cos(angle));
                    const y = b * (1 + Math.sin(angle));
                    pegs.push({ x, y, angle });
                    const dAngle = step / Math.sqrt(a * a * Math.sin(angle) * Math.sin(angle) + b * b * Math.cos(angle) * Math.cos(angle));
                    angle += dAngle;
                }
            } else if (shape === EShape.CIRCLE) {
                // حساب دبابيس الدائرة
                const radius = Math.min(width, height) / 2;
                const centerX = width / 2;
                const centerY = height / 2;
                for (let i = 0; i < pegsCount; i++) {
                    const angle = (2 * Math.PI * i) / pegsCount;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    pegs.push({ x, y, angle });
                }
            }

            // قياس الدبابيس إلى حجم canvas المخفي
            const scaleX = this.hiddenCanvas.width / width;
            const scaleY = this.hiddenCanvas.height / height;
            for (const peg of pegs) {
                peg.x *= scaleX;
                peg.y *= scaleY;
            }

            return pegs;
        }

        static computeBestSize(image, maxDimension) {
            const scale = maxDimension / Math.max(image.width, image.height);
            return {
                width: Math.ceil(image.width * scale),
                height: Math.ceil(image.height * scale)
            };
        }

        computeNextSegments(maxTime) {
            const startTime = performance.now();
            const targetSegments = Parameters.nbLines;

            if (this.nbSegments >= targetSegments) {
                return false;
            }

            let currentColor = null;
            while (this.nbSegments < targetSegments && performance.now() - startTime < maxTime) {
                const threadToGrow = this.thread.getThreadToGrow();
                if (currentColor !== threadToGrow.color) {
                    currentColor = threadToGrow.color;
                    this.hiddenCanvasContext.globalCompositeOperation = 'lighter';
                    this.thread.enableSamplingFor(currentColor);
                }
                this.computeSegment(threadToGrow.thread);
                this.nbSegments++;
                if (this.nbSegments % 100 === 0) {
                    this.computeError();
                }
            }

            return true;
        }

        computeSegment(thread) {
            let fromPeg, toPeg;
            if (thread.length === 0) {
                const bestStart = this.computeBestStartingSegment();
                thread.push(bestStart.peg1);
                fromPeg = bestStart.peg1;
                toPeg = bestStart.peg2;
            } else {
                fromPeg = thread[thread.length - 1];
                const recentPegs = thread.slice(-Math.min(thread.length, 20));
                toPeg = this.computeBestNextPeg(fromPeg, recentPegs);
            }
            thread.push(toPeg);
            this.drawSegmentOnHiddenCanvas(fromPeg, toPeg);
            // تحديث طول الخيط
            this.totalThreadLength += this.distanceBetween(fromPeg, toPeg);
        }

        distanceBetween(p1, p2) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        drawSegmentOnHiddenCanvas(from, to) {
            this.hiddenCanvasContext.beginPath();
            this.hiddenCanvasContext.moveTo(from.x, from.y);
            this.hiddenCanvasContext.lineTo(to.x, to.y);
            this.hiddenCanvasContext.stroke();
            this.hiddenCanvasContext.closePath();
            this.hiddenCanvasData = null; // بحاجة إلى تحديث
        }

        computeBestStartingSegment() {
            const candidates = [];
            let bestPotential = -Infinity;
            const step = Math.max(1, Math.floor(this.pegs.length / 100));

            for (let i = 0; i < this.pegs.length; i += step) {
                for (let j = i + 1; j < this.pegs.length; j += step) {
                    const peg1 = this.pegs[i];
                    const peg2 = this.pegs[j];
                    if (!this.arePegsTooClose(peg1, peg2)) {
                        const potential = this.computeSegmentPotential(peg1, peg2);
                        if (potential > bestPotential) {
                            bestPotential = potential;
                            candidates.length = 0;
                            candidates.push({ peg1, peg2 });
                        } else if (potential === bestPotential) {
                            candidates.push({ peg1, peg2 });
                        }
                    }
                }
            }

            return candidates[Math.floor(Math.random() * candidates.length)];
        }

        computeBestNextPeg(from, recentPegs) {
            const candidates = [];
            let bestPotential = -Infinity;

            for (const peg of this.pegs) {
                if (!this.arePegsTooClose(from, peg) && !recentPegs.includes(peg)) {
                    const potential = this.computeSegmentPotential(from, peg);
                    if (potential > bestPotential) {
                        bestPotential = potential;
                        candidates.length = 0;
                        candidates.push(peg);
                    } else if (potential === bestPotential) {
                        candidates.push(peg);
                    }
                }
            }

            return candidates[Math.floor(Math.random() * candidates.length)];
        }

        arePegsTooClose(peg1, peg2) {
            const shape = Parameters.shape;
            if (shape === EShape.RECTANGLE) {
                return peg1.x === peg2.x || peg1.y === peg2.y;
            } else if (shape === EShape.ELLIPSIS || shape === EShape.CIRCLE) {
                const angle1 = peg1.angle;
                const angle2 = peg2.angle;
                const diff = Math.abs(angle1 - angle2);
                const minDiff = Math.min(diff, 2 * Math.PI - diff);
                return minDiff <= (2 * Math.PI) / 16;
            }
            return false;
        }

        computeSegmentPotential(peg1, peg2) {
            this.uploadCanvasDataToCPU();
            const length = this.distanceBetween(peg1, peg2);
            const steps = Math.ceil(length);
            let total = 0;

            for (let i = 0; i < steps; i++) {
                const t = (i + 1) / (steps + 1);
                const point = {
                    x: peg1.x * (1 - t) + peg2.x * t,
                    y: peg1.y * (1 - t) + peg2.y * t
                };
                const sample = this.sampleCanvasData(point);
                total += 127 - (sample + 255 * this.lineOpacityInternal);
            }

            return total / steps;
        }

        uploadCanvasDataToCPU() {
            if (this.hiddenCanvasData === null) {
                this.hiddenCanvasData = this.hiddenCanvasContext.getImageData(
                    0, 0, this.hiddenCanvas.width, this.hiddenCanvas.height
                );
            }
        }

        sampleCanvasData(point) {
            const data = this.hiddenCanvasData.data;
            const width = this.hiddenCanvasData.width;
            const height = this.hiddenCanvasData.height;

            const x1 = Math.max(0, Math.min(width - 1, Math.floor(point.x)));
            const x2 = Math.max(0, Math.min(width - 1, Math.ceil(point.x)));
            const y1 = Math.max(0, Math.min(height - 1, Math.floor(point.y)));
            const y2 = Math.max(0, Math.min(height - 1, Math.ceil(point.y)));

            const sample = (x, y) => {
                const index = 4 * (x + y * width);
                return this.thread.sampleCanvas(data, index);
            };

            const q11 = sample(x1, y1);
            const q21 = sample(x2, y1);
            const q12 = sample(x1, y2);
            const q22 = sample(x2, y2);

            const x = point.x % 1;
            const y = point.y % 1;

            const r1 = q11 * (1 - x) + q21 * x;
            const r2 = q12 * (1 - x) + q22 * x;
            return r1 * (1 - y) + r2 * y;
        }

        computeError() {
            this.uploadCanvasDataToCPU();
            const data = this.hiddenCanvasData.data;
            const totalPixels = this.hiddenCanvasData.width * this.hiddenCanvasData.height;
            let sum = 0, sumSquares = 0;

            for (let i = 0; i < totalPixels; i++) {
                const index = 4 * i;
                const r = 127 - data[index];
                const g = 127 - data[index + 1];
                const b = 127 - data[index + 2];
                sum += r + g + b;
                sumSquares += r * r + g * g + b * b;
            }

            this.error.average = Math.round(sum / (3 * totalPixels));
            this.error.meanSquare = Math.round(sumSquares / (3 * totalPixels));

            let variance = 0;
            for (let i = 0; i < totalPixels; i++) {
                const index = 4 * i;
                const r = 127 - data[index];
                const g = 127 - data[index + 1];
                const b = 127 - data[index + 2];
                const value = (r + g + b) / 3 - this.error.average;
                variance += value * value;
            }
            this.error.variance = Math.round(variance / (3 * totalPixels));
        }

        updateIndicators(callback) {
            callback('pegs-count', this.pegs.length.toString());
            callback('segments-count', this.nbSegments.toString());
            callback('error-average', this.error.average.toString());
            callback('error-mean-square', this.error.meanSquare.toString());
            callback('error-variance', this.error.variance.toString());

            // حساب الطول الحقيقي (باستخدام حجم اللوحة الحقيقي)
            const scaleX = (Parameters.canvasWidth || 1000) / this.hiddenCanvas.width;
            const scaleY = (Parameters.canvasHeight || 1000) / this.hiddenCanvas.height;
            const realLength = this.totalThreadLength * Math.max(scaleX, scaleY);
            callback('thread-length', `Length: ${realLength.toFixed(0)} mm`);
        }

        drawThread(plotter, startSegment) {
            const transformation = this.computeTransformation(plotter.size);
            const lineThickness = transformation.scaling * this.hiddenCanvasScale * this.lineThickness;
            const operation = Parameters.invertColors ? 
                ECompositingOperation.LIGHTEN : ECompositingOperation.DARKEN;

            this.thread.iterateOnThreads(startSegment, (pegs, color) => {
                const transformedPegs = pegs.map(peg => transformation.transform(peg));
                plotter.drawBrokenLine(transformedPegs, color, this.lineOpacity, operation, lineThickness);
            });
        }

        drawPegs(plotter) {
            const transformation = this.computeTransformation(plotter.size);
            const pegSize = transformation.scaling * this.hiddenCanvasScale * 0.5;
            const transformedPegs = this.pegs.map(peg => transformation.transform(peg));
            plotter.drawPoints(transformedPegs, 'red', pegSize);
        }

        computeTransformation(targetSize) {
            const sourceSize = {
                width: this.hiddenCanvas.width,
                height: this.hiddenCanvas.height
            };
            const scale = Math.min(
                targetSize.width / sourceSize.width,
                targetSize.height / sourceSize.height
            );
            const origin = {
                x: 0.5 * (targetSize.width - scale * sourceSize.width),
                y: 0.5 * (targetSize.height - scale * sourceSize.height)
            };
            return {
                scaling: scale,
                origin: origin,
                transform: function(point) {
                    return {
                        x: origin.x + point.x * scale,
                        y: origin.y + point.y * scale
                    };
                }
            };
        }

        get instructions() {
            if (Parameters.mode !== EMode.MONOCHROME) {
                return "Instructions are only available for monochrome mode.";
            }
            if (Parameters.invertColors) {
                return "Instructions are only available for black thread.";
            }

            let maxX = -1, maxY = -1;
            for (const peg of this.pegs) {
                if (peg.x > maxX) maxX = peg.x;
                if (peg.y > maxY) maxY = peg.y;
            }

            const lines = [];
            lines.push("Generated by Thread Art Generator.");
            lines.push(`Canvas size: ${Parameters.canvasWidth} x ${Parameters.canvasHeight} mm`);
            lines.push(`Total thread length: ${this.totalThreadLength.toFixed(0)} mm`);

            lines.push("\nPeg positions:");
            for (let i = 0; i < this.pegs.length; i++) {
                const peg = this.pegs[i];
                lines.push(`  PEG_${i}: x=${peg.x.toFixed(2)}, y=${peg.y.toFixed(2)}`);
            }

            lines.push("\nThread path:");
            this.thread.iterateOnThreads(0, (pegs, color) => {
                lines.push(`  Start at PEG_${this.pegs.indexOf(pegs[0])}`);
                for (let i = 1; i < pegs.length; i++) {
                    lines.push(`  Then to PEG_${this.pegs.indexOf(pegs[i])} (segment ${i}/${pegs.length-1})`);
                }
            });

            return lines.join('\n');
        }
    }

    // ============== رسم الخيط ==============
    class ThreadPlotter {
        constructor(plotter, threadComputer) {
            this.plotter = plotter;
            this.threadComputer = threadComputer;
            this.nbSegmentsDrawn = 0;
        }

        reset() {
            this.nbSegmentsDrawn = 0;
        }

        plot() {
            if (this.nbSegmentsDrawn !== this.threadComputer.nbSegments) {
                if (this.nbSegmentsDrawn > this.threadComputer.nbSegments) {
                    this.nbSegmentsDrawn = 0;
                }

                if (this.nbSegmentsDrawn === 0) {
                    const settings = {
                        backgroundColor: Parameters.invertColors ? 'black' : 'white',
                        blur: Parameters.blur
                    };
                    this.plotter.resize();
                    this.plotter.initialize(settings);
                    if (Parameters.displayPegs) {
                        this.threadComputer.drawPegs(this.plotter);
                    }
                    this.threadComputer.drawThread(this.plotter, 0);
                    this.plotter.finalize();
                } else {
                    this.threadComputer.drawThread(this.plotter, this.nbSegmentsDrawn);
                }
                this.nbSegmentsDrawn = this.threadComputer.nbSegments;
            }
        }
    }

    // ============== التهيئة الرئيسية ==============
    function initialize() {
        // إنشاء رسام canvas
        const plotter = new PlotterCanvas2D('canvas');

        // إنشاء معالج الخيط
        let threadComputer = null;
        let threadPlotter = null;

        // تحميل الصورة الافتراضية
        const defaultImage = new Image();
        defaultImage.src = './resources/cat.jpg'; // تأكد من وجود هذه الصورة

        defaultImage.onload = function() {
            threadComputer = new ThreadComputer(defaultImage);
            threadPlotter = new ThreadPlotter(plotter, threadComputer);
            startAnimation();
        };

        // دورة الرسوم المتحركة
        function startAnimation() {
            function animate() {
                if (threadComputer.computeNextSegments(20)) {
                    threadPlotter.plot();
                    threadComputer.updateIndicators((id, text) => {
                        // تحديث المؤشرات في الواجهة
                        const element = document.getElementById(`${id}-indicator`);
                        if (element) {
                            element.textContent = text;
                        }
                    });
                }
                requestAnimationFrame(animate);
            }
            animate();
        }

        // ربط أحداث التحكم
        function setupControls() {
            // تحديث عند تغيير أي إعداد
            const controls = document.querySelectorAll('input, select');
            controls.forEach(control => {
                control.addEventListener('change', () => {
                    if (threadComputer) {
                        threadComputer.reset(Parameters.linesOpacity, Parameters.linesThickness);
                        threadPlotter.reset();
                    }
                });
            });

            // تحميل صورة
            const uploadInput = document.getElementById('image-upload');
            if (uploadInput) {
                uploadInput.addEventListener('change', function(event) {
                    const file = event.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            const img = new Image();
                            img.onload = function() {
                                threadComputer = new ThreadComputer(img);
                                threadPlotter = new ThreadPlotter(plotter, threadComputer);
                            };
                            img.src = e.target.result;
                        };
                        reader.readAsDataURL(file);
                    }
                });
            }

            // تنزيل النتيجة كSVG
            const downloadButton = document.getElementById('download-button');
            if (downloadButton) {
                downloadButton.addEventListener('click', () => {
                    // هنا يمكن إضافة دالة لتصدير SVG
                    // لكننا نركز على canvas حالياً
                    Helpers.downloadTextFile(threadComputer.instructions, 'thread-instructions.txt');
                });
            }

            // تنزيل التعليمات
            const instructionsButton = document.getElementById('instructions-button');
            if (instructionsButton) {
                instructionsButton.addEventListener('click', () => {
                    Helpers.downloadTextFile(threadComputer.instructions, 'thread-instructions.txt');
                });
            }
        }

        setupControls();
    }

    // بدء التطبيق عندما تكون الصفحة جاهزة
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initialize);
    } else {
        initialize();
    }

})();
